// Generated by CoffeeScript 1.7.1
(function() {
  var DuplexStream, EVP_BytesToKey, ShadowStream, bytes_to_key_results, crypto, getCipherLen, int32Max, method_supported, stream, tls, to_buffer, util;

  crypto = require("crypto");

  tls = require("tls");

  util = require("util");

  stream = require('stream');

  int32Max = Math.pow(2, 32);

  bytes_to_key_results = {};

  EVP_BytesToKey = function(password, key_len, iv_len) {
    var count, d, data, i, iv, key, m, md5, ms;
    password = to_buffer(password);
    if (bytes_to_key_results[password]) {
      return bytes_to_key_results[password];
    }
    m = [];
    i = 0;
    count = 0;
    while (count < key_len + iv_len) {
      md5 = crypto.createHash('md5');
      data = password;
      if (i > 0) {
        data = Buffer.concat([m[i - 1], password]);
      }
      md5.update(data);
      d = to_buffer(md5.digest());
      m.push(d);
      count += d.length;
      i += 1;
    }
    ms = Buffer.concat(m);
    key = ms.slice(0, key_len);
    iv = ms.slice(key_len, key_len + iv_len);
    bytes_to_key_results[password] = [key, iv];
    return [key, iv];
  };

  to_buffer = function(input) {
    if (input.copy != null) {
      return input;
    } else {
      return new Buffer(input, 'binary');
    }
  };

  method_supported = {
    'aes-128-cfb': [16, 16],
    'aes-192-cfb': [24, 16],
    'aes-256-cfb': [32, 16],
    'bf-cfb': [16, 8],
    'camellia-128-cfb': [16, 16],
    'camellia-192-cfb': [24, 16],
    'camellia-256-cfb': [32, 16],
    'cast5-cfb': [16, 8],
    'des-cfb': [8, 8],
    'idea-cfb': [16, 8],
    'rc2-cfb': [16, 8],
    'rc4': [16, 0],
    'seed-cfb': [16, 16]
  };

  getCipherLen = function(method) {
    var m;
    method = method.toLowerCase();
    m = method_supported[method];
    return m;
  };

  DuplexStream = stream.Duplex;

  ShadowStream = function(source, method, password) {
    var iv_, m, self, _ref;
    DuplexStream.call(this);
    if (!(method in method_supported)) {
      throw new Error("method " + method + " not supported");
    }
    method = method.toLowerCase();
    this._source = source;
    this._method = method;
    this._password = password;
    this._IVSent = false;
    this._IVBytesReceived = 0;
    m = getCipherLen(method);
    _ref = EVP_BytesToKey(password, m[0], m[1]), this._key = _ref[0], iv_ = _ref[1];
    this._sendIV = crypto.randomBytes(m[1]);
    this._cipher = crypto.createCipheriv(method, this._key, this._sendIV);
    this._receiveIV = new Buffer(m[1]);
    this._IVBytesToReceive = m[1];
    this.timeout = source.timeout;
    self = this;
    source.on('connect', function() {
      return self.emit('connect');
    });
    source.on('end', function() {
      return self.push(null);
    });
    source.on('readable', function() {
      return self.read(0);
    });
    source.on('error', function(err) {
      return self.emit('error', err);
    });
    source.on('timeout', function() {
      return self.emit('timeout');
    });
    source.on('close', function() {
      return self.emit('close');
    });
    return this;
  };

  util.inherits(ShadowStream, DuplexStream);

  ShadowStream.prototype._read = function(bytes) {
    var chunk, cipher, decipherStart, plain;
    chunk = this._source.read();
    if (chunk === null) {
      return this.push('');
    }
    if (chunk.length === 0) {
      return this.push(chunk);
    }
    decipherStart = 0;
    if (this._IVBytesReceived < this._IVBytesToReceive) {
      decipherStart = chunk.copy(this._receiveIV, this._IVBytesReceived);
      this._IVBytesReceived += decipherStart;
    }
    if (this._IVBytesReceived < this._IVBytesToReceive) {
      return;
    }
    if (this._decipher == null) {
      this._decipher = crypto.createDecipheriv(this._method, this._key, this._receiveIV);
    }
    if (decipherStart > 0) {
      cipher = chunk.slice(decipherStart);
    } else {
      cipher = chunk;
    }
    if (cipher.length > 0) {
      plain = this._decipher.update(cipher);
      return this.push(plain);
    }
  };

  ShadowStream.prototype._write = function(chunk, encoding, callback) {
    var cipher, e;
    if (chunk instanceof String) {
      chunk = new Buffer(chunk, encoding);
    }
    try {
      cipher = this._cipher.update(chunk);
      if (!this._IVSent) {
        this._IVSent = true;
        cipher = Buffer.concat([this._sendIV, cipher]);
      }
      this._source.write(cipher);
    } catch (_error) {
      e = _error;
      return callback(e);
    }
    return callback();
  };

  ShadowStream.prototype.end = function(data) {
    return this._source.end(data);
  };

  ShadowStream.prototype.destroy = function() {
    return this._source.destroy();
  };

  ShadowStream.prototype.setTimeout = function(timeout) {
    return this._source.setTimeout(timeout);
  };

  exports.ShadowStream = ShadowStream;

}).call(this);
